// Rules of array modification. 
// An array can only be modified if it is provable that there is a single reference to it.
// The function that creates the array can modify it. 
// An array passed as an argument can not be modified.  

module heron_tests 
{
    function min(x, y) {
        return x <= y ? x : y;
    }

    function max(x, y) {
        return x <= y ? x : y;
    }

    function shorter(xs, ys) {
        return xs.length <= ys.length ? xs : ys;
    }

    function longer(xs, ys) {
        return xs.length >= ys.length ? xs : ys;
    }

    function empty(xs) {
        return xs.length == 0;
    }

    function at(xs, i) {
        return xs[i];
    }

    function selectByIndex(xs, indices) {
        return indices.map(i => xs.at(i));
    }

    function indices(xs) {
        return 0 .. xs.length;
    }

    function zip(xs, ys, f) {
        return xs.length <= ys.length 
            ? xs.map((x, i) => f(x, ys[i]))
            : ys.map((x, y) => f(x, xs[i]));
    }

    function all(xs, p) {
        return xs.reduce(true, (prev, x) => prev && p(x));
    }

    function any(xs, p) {
        return xs.reduce(false, (prev, x) => prev || p(x));
    }

    function count(xs, p) {
        return xs.reduce(0, (prev, x) => p(x) ? prev + 1 : prev);    
    }

    function eq(xs, ys) {
        return xs.length == ys.length;
    }

    function filter(xs, p) {
        var ys = xs.mutable;
        var i = 0;
        for (var x in xs) 
            if (p(x)) 
                ys[i++] = x;
        return ys.take(i);
    }

    function repeat(x, n) {
        return (0 .. n).map(i => x);
    }

    function prefixScan(xs, op) {
        if (xs.empty) return xs;
        var ys = xs[0].repeat(xs.length).mutable();
        for (var i in 1 .. ys.length)
            ys[i] = op(xs[i], ys[i-1]);
        return ys;
    }

    function adjacentDifferences(xs) {
        return xs.indices.map(i => i > 0 ? xs[i] - xs[i-1] : xs[i]);
    }

    function slice(xs, from, to) {
        return (from .. to).map(xs.at);
    }

    function stride(xs, n) {
        return (0 .. xs.length / n).map(i => xs[i * n]);
    }

    function slices(xs, n) {
        return (0 .. n).map(i => xs.slice(i * n, (i+1) * n));
    }

    function take(xs, n) {
        return xs.slice(0, n);
    }

    function skip(xs, n) {
        return xs.slice(n, xs.length - n);
    }

    function dropSuffix(xs, n) {
        return xs.take(xs.length - n);
    }

    function suffix(xs, n) {
        return xs.skip(xs.length-n);
    }

    function reverse(xs, n) {
        return xs.indices.map(i => xs[xs.length-1-i]);
    }

    function gen(cnt, f) {
        return (0 .. cnt).map(f);
    }

    function concat(xs, ys) {
        return gen(xs.length + ys.length, i => i < xs.length ? xs[i] : ys[i - xs.length]);
    }

    function cut(xs, from, n) {
        return gen(xs.length - n, i < from ? xs[i] : xs[i + n]);
    }

    function splice(xs, from, ys) {
        return xs.take(from).concat(ys).concat(xs.drop(from));
    }

    function mul(x, y) {
        return x * y;
    }

    function add(x, y) {
        return x + y;
    }

    function sum() {
        return xs.reduce(0, add);
    }

    function product(xs) {
        return xs.reduce(1, mul);
    }
    
    function average(xs) {
        return xs.sum / xs.length;
    }

    function minElement(xs) {
        return xs.reduce(xs[0], min);
    }

    function maxElement(xs) {
        return xs.reduce(xs[0], max);
    }

    // https://en.wikipedia.org/wiki/Quicksort
    function sort(xs) {
        var a = xs.mutable();

        // A function cannot modify an array passed to it. 
        // A function that captures a variable and modifies it cannot be passed 
        // as a lambda. It is an effectful function. 
        function qsort(a, lo, hi) 
        {
            function partition() 
            {
                pivot = a[lo];
                var i = lo-1;
                var j = hi+1;
                while (true) {
                    do { i++; } while (a[i] < pivot);
                    do { j--; } while (a[j] > pivot);
                    if (i >= j) return j;
                    var tmp = a[i];
                    a[i] = a[j];
                    a[j] = tmp;
                }
            }
            if (lo < hi) {
                p = partition();
                qsort(a, lo, p);
                qsort(a, p+1, hi);
            }
        }
        return a;
    }    

    function median(xs) {        
        var ys = xs.sort();
        return ys.length % 2 == 0 
            ? ys[ys.length / 2] 
            : ys[ys.length / 2 - 1] + ys[ys.length / 2 + 1] / 2;
    }

    function inrange(xs, n) {
        return n >= 0 && n < xs.length;
    }

    function last(xs) {
        return xs[xs.length - 1];
    }

    function first(xs) {
        return xs[0];
    }

    var pi = 3.14159265353897;

    // https://en.wikipedia.org/wiki/Gaussian_blur
    function gaussian_blur(x, y, sigma) {
        return pow(1 / (2 * pi * sigma* sigma) * e,  -(x*x + y*y) / (2 * sigma * sigma));
    }
}