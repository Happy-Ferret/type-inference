        // Call this for every variable assignment or declaration. 
        addVarConstraint(varName:string, typeExpr:TypeExpr, location = undefined)  : TypeExpr {
            if (!(varName in this.varToType))
                this.varToType[varName] = typeExpr;  
            else 
                this.addTypeConstraint(this.varToType[varName], typeExpr, location);
            return typeExpr;
        }

        // Call this for every function application in the function.
        addFunctionCall(func:TypeList, args:TypeExpr[], location) : TypeExpr {
            // Check that the number of arguments matches the function
            if (func.types.length < 1 || func.types[0] != 'function') 
                throw Error("Not a function type.");
            if (func.types.length + 1 != args.length)
                throw Error("The number of arguments " + args.length + " is not what was expected: " + func.types.length + 1);
            // Provide unique variable names to the type signature. 
            func = <TypeList>renameTypeVars(func, this.constraints.length);
            // Constrain the arguments 
            for (var i=0; i < args.length; ++i)
                this.addTypeConstraint(args[i], func.types[i+1], location);
            // TODO: this is something expressed in terms of variables that are resolved elsewhere. 
            return func.types[0];
        }        

        // Call this for every return statement in the function
        addReturnStatement(expr:TypeExpr, location) {
            this.addVarConstraint(this.resultVarName, expr, location);
        }
